Rails 6 + Vue generator template built with `Docker` and `docker-compose` to **_plug and play_**!

## Running Locally

### Requirements

The requirements for this template are simple:

* `Docker`
* `Docker Compose`

Additionally, to deploy to `heroku` you will need:

* `Heroku`

### Plug and Play

This repo comes with a `docker-compose.yml` file to handle using a `postgres` image pulled from the web. To get `on rails` quickly, build the image:

```sh
docker-compose build
```

Then, create the database:

```sh
docker-compose run web bundle exec rails db:create
```

Finally, start the server:

```sh
docker-compose up
```

Your app can now be found in `localhost:3000`. From now on, every command regarding the app that should be run as `[COMMAND]` will now be run as `docker-compose run web [COMMAND]`. This includes database migrations (`docker-compose run web bundle exec rails db:migrate`).

### Caveats (or, may I say, Docker and Windows)

If you are using `Docker` on _Linux_, `Docker` on _MacOS_ or `Docker` on `WSL2`, chances are your usage process has been almost flawless, and the instructions given in the tutorial worked at the first try. However, if you are using `Docker Toolbox` on Windows or `Docker for Windows` on Windows, things are different. Mainly, two things change:

* Due to the technology being run inside a _Virtual Machine_, instead of finding your app in `localhost:3000`, your app will be defaulted to `192.168.99.100:3000` and will **not** be found in `localhost:3000`.
* Due to the database volume being mounted to a _named volume_ created by the _Virtual Machine_, every Docker update **will** wipe your database clean. When using for development purposes, some simple seeds are enough to make this a _no-problem_. Keep an eye if that is your production environment, though, as data **will** be lost if you are not careful.

### Docker Image

The image generated by `docker-compose build` with the original repo contains a standard Rails 6 app using `postgresql` as the database, `sass` as the stylesheet pre-processor, `puma` as the webserver and `Vue` as a frontend framework, with _Hot Module Replacement_ configured **out of the box**! ✨

### When to Build

The command `docker-compose build` must be used only in 2 cases:

1. Changes in the `package.json`: `docker-compose build` will notice if either the `package.json` or the `yarn.lock` present any changes. If so, it will re-run `yarn install` to update the image.
2. Changes in the `Gemfile`: `docker-compose build` will notice if either the `Gemfile` or the `Gemfile.lock` present any changes. If so, it will re-run `bundle install` to update the image (this **will** take a while, so go make yourself a coffee. Also, _try_ to change the `Gemfile` as little as possible if you value your time at all)

Notice that `Docker` is **really smart**, and if you run `docker-compose build` and neither `package.json` nor `Gemfile` have changed, `Docker` will use cached layers to build the image, dramatically decreasing the amount of time wasted in your life (hopefully).

## Heroku Deployment

### Automagic Deployment

The template includes a GitHub Action to **automagically** deploy your app to `heroku`! On every push to `master` (or whenever a Pull Request gets merged into `master`), the workflow will trigger and build, push and deploy your app to `heroku`, including database migrations! For this **magic** ✨ to work, make sure to do the following stuff:

1. Get your `heroku` API Key from your `heroku` dashboard and add it as a GitHub Secret to your repository with a key corresponding to `HEROKU_API_KEY`.
2. Make sure to have a `heroku` app created. Get the app name and add it as a GitHub Secret to your repository with a key corresponding to `APP_NAME`.
3. Make sure that your app has the `heroku-postgresql` addon provisioned. You can provision it from the dashboard or by running `heroku addons:create heroku-postgresql:hobby-dev -a <appname>` from your terminal, where `<appname>` corresponds to the name of your `heroku` app.

So, to sum up, you should have the following GitHub Secrets in your repo:

- `HEROKU_API_KEY`: your API key for `heroku`
- `APP_NAME`: the name of your app in `heroku`

That's it! Your app should be now deploying **automagically**!

### Manual Deployment

If you still want to deploy your app manually, you can use the Container Registry. To deploy to `heroku` using Container Registry, make sure to be logged in to the platform (`heroku login`). Then, log in to Container Registry:

```sh
heroku container:login
```

After that, create a new `heroku` app:

```sh
heroku create
```

Don't forget to add the `heroku-postgresql` addon to your `heroku` app (when deploying to `heroku`, only the Rails app will be deployed, and the `postgres` container used locally must be replaced with the `heroku-postgresql` addon):

```sh
heroku addons:create heroku-postgresql:hobby-dev
```

This command will add the **free** basic `heroku-postgresql` addon to your app (you can upgrade this later if you desire).

Next, build the image and push it to Container Registry:

```sh
heroku container:push web
```

Finally, release the image to your app:

```sh
heroku container:release web
```

**Important Note**: Once your app is created, to push new changes you only have to run `heroku container:push web` and then `heroku container:release web`.

To open the app in a browser, you can run `heroku open`. You can also access directly using the app's URL.

## Amazon EC2 Deployment

The output also includes a `nginx` image configured to serve the static assets and serve as a _reverse proxy_ to the Rails application. Once the code is in your `EC2` instance (and the port `80` is opened for `HTTP` traffic), create a `.env.production` file:

```sh
cp .env.production.example .env.production
```

Then, adjust it to your environment:

```sh
nano .env.production
```

Notice that you will have to setup an external database for the application (probably using `RDS`).

You can use `bin/production` for some abbreviations to `docker-compose` commands. To build the images and setup the environment, run the following commands:

```sh
# Build the images
bin/production build

# Create and migrate the database
bin/production db:create
bin/production db:migrate

# Start the containers
bin/production start
```

You can stop the containers by running `bin/production stop`.

## Additional Features

The template also includes a Pull Request template. That means that every Pull Request's comment will get **automagically** filled with a default structure that can get altered.
